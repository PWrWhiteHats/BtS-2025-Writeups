# Rainbom Bash Adventure

# Write-up

The challenge is a renpy visual novel. You can find the code of the game
in `./game/script.rpy`. There what you have to do is to parse all the choices
as a weighted graph and solve the TSP problem using heuristics.
You can tell it's a TSP problem by the dialogue:
`Help Rainbom Bash smash all the clouds in the fastest possible way and return to the origin. I heard it's a well known problem...`.

I am ashamed to admit that the `GeneticTSP` class was vibe coded.
Looks like it often gets stuck on some local minimum, so I always have to play
around with the parameters for it to find the solution, but it's good enough.

Anyway, there is the solve script:

```python
import random
import hashlib
from collections import defaultdict

import numpy as np


flag = b""


def xor(target, key):
    out = [c ^ key[i % len(key)] for i, c in enumerate(target)]
    return bytearray(out)


def key_from_path(path):
    return hashlib.sha256(str(path).encode()).digest()


def check_path(path, enc_flag):
    global flag
    flag1 = xor(enc_flag, key_from_path(path))
    flag2 = xor(enc_flag, key_from_path(list(reversed(path))))
    print(path)
    if flag1.startswith(b"BtSCTF"):
        flag = flag1
        print(flag)
        flag = bytes(flag).replace(b"{", b"{{").decode('ascii')
        return True
    if flag2.startswith(b"BtSCTF"):
        flag = flag2
        print(flag)
        flag = bytes(flag).replace(b"{", b"{{").decode('ascii')
        return True
    return False


class Graph:
    def __init__(self, size):
        self.size = size
        self.nodes = defaultdict(lambda : {})

    def get_matrix(self):
        m = [[0 for _ in range(self.size)] for _ in range(self.size)]
        for v, neighbours in self.nodes.items():
            for neighbour, weight in neighbours.items():
                m[v][neighbour] = weight
        return m


if __name__ == '__main__':
    random.seed(0xc0fe)
    g = Graph(20)
    f = open("rainbow bash adventure/game/script.rpy", "r")
    c = f.read()
    labels = c.split('label cloud')[1:]
    labels[-1] = labels[-1].split('label ending:')[0]


    for label in labels:
        node = int(label.split(':')[0])
        for line in label.split('\n'):
            if 'which is' not in line:
                continue
            to = int(line.split('to cloud')[1].split(' which')[0])
            weight = int(line.split('which is ')[1].split(' pony')[0])
            if node == to:
                continue
            print(node, to)
            g.nodes[node][to] = weight
            g.nodes[to][node] = weight

    import solvers
    solver = solvers.GeneticTSP(
        distance_matrix=np.array(g.get_matrix()),
        population_size=200,
        mutation_rate=0.1,
        elitism_rate=0.1
    )
    perm, dist = solver.solve(8)
    print(dist)
    print(perm)
    while perm[0] != 0:
        perm.append(perm.pop(0))
    perm.append(0)
    is_correct = check_path(perm, bytearray(b'\xc2\x92\xf9\xf66\xe8\xa5\xa6\x17\xb6mGE\xcfQ\x90Mk:\x9a\xbb\x905&\x19\x8e\xc4\x9a\x0b\x1f\xf8C\xf4\xb9\xc9\x85R\xc2\xbb\x8d\x07\x94[R_\xf5z\x9fAl\x11\x9c\xbb\x9255\x08\x8e\xf6\xd6\x04'))
```


and there's the solvers.py file, if you want to look:

```python
import time
import random
from typing import List, Tuple
import numpy as np


# Generated by claude for testing
class GeneticTSP:
    def __init__(self, distance_matrix: np.ndarray, population_size: int = 100, 
                 mutation_rate: float = 0.05, elitism_rate: float = 0.1):
        """
        Initialize the Genetic Algorithm TSP solver.
        
        Args:
            distance_matrix: Square matrix where distance_matrix[i][j] is distance from city i to j
            population_size: Number of individuals in the population
            mutation_rate: Probability of mutation for each gene
            elitism_rate: Proportion of best individuals to keep unchanged
        """
        self.distance_matrix = distance_matrix
        self.num_cities = distance_matrix.shape[0]
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.elitism_count = max(1, int(population_size * elitism_rate))
        
        # Initialize population with random permutations
        self.population = [self._random_route() for _ in range(population_size)]
        self.best_route = None
        self.best_distance = float('inf')
        
    def _random_route(self) -> List[int]:
        """Generate a random route (permutation of cities)."""
        route = list(range(self.num_cities))
        random.shuffle(route)
        return route
    
    def _calculate_fitness(self, route: List[int]) -> float:
        """Calculate the fitness of a route (inverse of total distance)."""
        distance = 0
        for i in range(self.num_cities):
            from_city = route[i]
            to_city = route[(i + 1) % self.num_cities]
            distance += self.distance_matrix[from_city][to_city]
        
        # Return inverse of distance (higher is better)
        return 1.0 / distance if distance > 0 else float('inf')
    
    def _calculate_distance(self, route: List[int]) -> float:
        """Calculate the total distance of a route."""
        distance = 0
        for i in range(self.num_cities):
            from_city = route[i]
            to_city = route[(i + 1) % self.num_cities]
            distance += self.distance_matrix[from_city][to_city]
        return distance
    
    def _selection(self) -> List[List[int]]:
        """Select individuals for breeding using tournament selection."""
        tournament_size = 3
        selected = []
        
        # Calculate fitness for each individual
        fitness_values = [self._calculate_fitness(route) for route in self.population]
        
        # Elitism: keep the best individuals
        elite_indices = np.argsort(fitness_values)[-self.elitism_count:]
        for idx in elite_indices:
            selected.append(self.population[idx])
        
        # Tournament selection for the rest
        while len(selected) < self.population_size:
            tournament = random.sample(range(self.population_size), tournament_size)
            tournament_fitness = [fitness_values[i] for i in tournament]
            winner_idx = tournament[tournament_fitness.index(max(tournament_fitness))]
            selected.append(self.population[winner_idx])
        
        return selected
    
    def _crossover(self, parent1: List[int], parent2: List[int]) -> List[int]:
        """Create a child using Ordered Crossover (OX)."""
        size = self.num_cities
        
        # Choose random start/end points for crossover
        start, end = sorted(random.sample(range(size), 2))
        
        # Initialize child with -1s
        child = [-1] * size
        
        # Copy segment from parent1
        child[start:end+1] = parent1[start:end+1]
        
        # Fill remaining positions with cities from parent2 (in order)
        parent2_remaining = [city for city in parent2 if city not in child]
        
        # Fill from the end of the segment to the end of the child
        for i in range(end + 1, size):
            child[i] = parent2_remaining.pop(0)
        
        # Fill from the beginning to the start of the segment
        for i in range(start):
            child[i] = parent2_remaining.pop(0)
            
        return child
    
    def _mutate(self, route: List[int]) -> List[int]:
        """Apply swap mutation to a route."""
        if random.random() < self.mutation_rate:
            idx1, idx2 = random.sample(range(self.num_cities), 2)
            route[idx1], route[idx2] = route[idx2], route[idx1]
        return route
    
    def _breed_population(self, selected: List[List[int]]) -> List[List[int]]:
        """Create a new population through crossover and mutation."""
        children = selected[:self.elitism_count]  # Keep elite individuals unchanged
        
        # Create remaining children
        while len(children) < self.population_size:
            parent1, parent2 = random.sample(selected, 2)
            child = self._crossover(parent1, parent2)
            child = self._mutate(child)
            children.append(child)
            
        return children
    
    def _update_best_route(self):
        """Update the best route found so far."""
        for route in self.population:
            distance = self._calculate_distance(route)
            if distance < self.best_distance:
                self.best_distance = distance
                self.best_route = route.copy()
    
    def solve(self, max_time_seconds: float, verbose: bool = True) -> Tuple[List[int], float]:
        """
        Solve the TSP problem using genetic algorithm with a time limit.
        
        Args:
            max_time_seconds: Maximum execution time in seconds
            verbose: Whether to print progress information
            
        Returns:
            Tuple containing the best route found and its distance
        """
        start_time = time.time()
        generation = 0
        
        while time.time() - start_time < max_time_seconds:
            # Perform one generation of the genetic algorithm
            selected = self._selection()
            self.population = self._breed_population(selected)
            self._update_best_route()
            
            generation += 1
            
            # Print progress every 10 generations
            if verbose and generation % 10 == 0:
                elapsed = time.time() - start_time
                print(f"Generation {generation}, Best distance: {self.best_distance:.2f}, Time: {elapsed:.2f}s")
        
        total_time = time.time() - start_time
        if verbose:
            print(f"\nFinished after {generation} generations ({total_time:.2f} seconds)")
            print(f"Best route: {self.best_route}")
            print(f"Distance: {self.best_distance}")
            
        return self.best_route, self.best_distance



def greedy_tsp_solver(distance_matrix: np.ndarray, 
                      start_city = None,
                      max_time_seconds: float = float('inf'),
                      verbose: bool = True) -> Tuple[List[int], float]:
    """
    Solves the Traveling Salesman Problem using a greedy nearest neighbor approach.
    
    Args:
        distance_matrix: Square matrix where distance_matrix[i][j] is distance from city i to j
        start_city: Index of starting city (random if None)
        max_time_seconds: Maximum execution time in seconds
        verbose: Whether to print progress information
        
    Returns:
        Tuple containing the best route found and its distance
    """
    start_time = time.time()
    num_cities = distance_matrix.shape[0]
    
    # If no start city is provided, try all possible starting cities
    # (within the time limit) and keep the best result
    if start_city is None:
        best_route = None
        best_distance = float('inf')
        
        for city in range(num_cities):
            # Check if we still have time
            if time.time() - start_time >= max_time_seconds:
                if verbose:
                    print(f"Time limit reached after exploring {city} starting cities")
                break
                
            route, distance = greedy_nearest_neighbor(distance_matrix, city)
            
            if distance < best_distance:
                best_distance = distance
                best_route = route
                
                if verbose:
                    elapsed = time.time() - start_time
                    print(f"New best route from start city {city}: {distance:.2f} (Time: {elapsed:.2f}s)")
        
        total_time = time.time() - start_time
        if verbose:
            print(f"\nFinished in {total_time:.2f} seconds")
            print(f"Best route: {best_route}")
            print(f"Distance: {best_distance}")
            
        return best_route, best_distance
    else:
        # Just run the algorithm with the specified start city
        route, distance = greedy_nearest_neighbor(distance_matrix, start_city)
        
        total_time = time.time() - start_time
        if verbose:
            print(f"\nFinished in {total_time:.2f} seconds")
            print(f"Route from city {start_city}: {route}")
            print(f"Distance: {distance}")
            
        return route, distance


def greedy_nearest_neighbor(distance_matrix: np.ndarray, start_city: int) -> Tuple[List[int], float]:
    """
    Builds a route using the nearest neighbor algorithm from a specified starting city.
    
    Args:
        distance_matrix: Square matrix where distance_matrix[i][j] is distance from city i to j
        start_city: Index of the starting city
        
    Returns:
        Tuple containing the route and its total distance
    """
    num_cities = distance_matrix.shape[0]
    unvisited = set(range(num_cities))
    unvisited.remove(start_city)
    
    route = [start_city]
    current_city = start_city
    total_distance = 0
    
    # Visit each city in order of closest to current position
    while unvisited:
        # Get distances from current city to all unvisited cities
        distances = [(city, distance_matrix[current_city, city]) for city in unvisited]
        
        # Find closest unvisited city
        next_city, distance = min(distances, key=lambda x: x[1])
        
        # Add to route and update total distance
        route.append(next_city)
        total_distance += distance
        
        # Update current position and unvisited set
        current_city = next_city
        unvisited.remove(next_city)
    
    # Add return to starting city to complete the tour
    total_distance += distance_matrix[route[-1], start_city]
    
    return route, total_distance
```
